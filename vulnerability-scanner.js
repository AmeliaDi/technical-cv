/**
 * Arch Linux Vulnerability Scanner
 * Simulated security scanner with IP detection
 * @author Amelia Enora ðŸŒˆ Marceline Chavez Barroso
 */

class VulnerabilityScanner {
    constructor() {
        this.scannerOutput = document.getElementById('scanner-output');
        this.ipInfo = null;
        this.vulnerabilities = [
            { port: 22, service: 'SSH', risk: 'medium', cve: 'CVE-2023-38408' },
            { port: 80, service: 'HTTP', risk: 'low', cve: 'CVE-2023-44487' },
            { port: 443, service: 'HTTPS', risk: 'low', cve: 'CVE-2023-44488' },
            { port: 3306, service: 'MySQL', risk: 'high', cve: 'CVE-2023-21980' },
            { port: 5432, service: 'PostgreSQL', risk: 'medium', cve: 'CVE-2023-5869' },
            { port: 6379, service: 'Redis', risk: 'high', cve: 'CVE-2023-41056' },
            { port: 27017, service: 'MongoDB', risk: 'medium', cve: 'CVE-2023-5363' },
            { port: 8080, service: 'HTTP-ALT', risk: 'medium', cve: 'CVE-2023-50164' }
        ];
        this.archPackages = [
            'linux 6.7.0.arch3-1',
            'systemd 255.2-2',
            'openssl 3.2.0-1',
            'openssh 9.6p1-1',
            'nginx 1.24.0-2',
            'docker 24.0.7-1',
            'postgresql 16.1-2',
            'python 3.11.7-1'
        ];
    }

    async init() {
        await this.detectIP();
        await this.startScan();
    }

    async detectIP() {
        try {
            // Using a free IP detection service
            const response = await fetch('https://ipapi.co/json/');
            this.ipInfo = await response.json();
        } catch (error) {
            // Fallback data if API fails
            this.ipInfo = {
                ip: this.generateRandomIP(),
                city: 'Unknown',
                region: 'Unknown',
                country_name: 'Unknown',
                org: 'Unknown ISP'
            };
        }
    }

    generateRandomIP() {
        return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
    }

    async startScan() {
        // Clear initial messages
        this.scannerOutput.innerHTML = '';
        
        // Initial scan messages
        await this.addScanLine('Starting Arch Linux Security Scanner v2.0.0', 'info');
        await this.delay(500);
        
        await this.addScanLine(`Detected IP: ${this.ipInfo.ip}`, 'success');
        await this.delay(300);
        
        await this.addScanLine(`Location: ${this.ipInfo.city}, ${this.ipInfo.region}, ${this.ipInfo.country_name}`, 'info');
        await this.delay(300);
        
        await this.addScanLine(`ISP: ${this.ipInfo.org}`, 'info');
        await this.delay(500);
        
        await this.addScanLine('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'divider');
        await this.addScanLine('Scanning for open ports and vulnerabilities...', 'warning');
        await this.delay(1000);
        
        // Scan ports
        await this.scanPorts();
        
        await this.addScanLine('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'divider');
        await this.addScanLine('Checking Arch Linux packages...', 'info');
        await this.delay(500);
        
        // Check packages
        await this.checkPackages();
        
        await this.addScanLine('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'divider');
        await this.addScanLine('Scan complete. Scroll down to see my CV!', 'success');
        
        // Update ASCII art
        this.updateASCIIStatus('complete');
    }

    async scanPorts() {
        // Randomly select some vulnerabilities to "find"
        const foundVulns = this.vulnerabilities
            .sort(() => Math.random() - 0.5)
            .slice(0, Math.floor(Math.random() * 4) + 2);
        
        for (const vuln of foundVulns) {
            await this.delay(400);
            const riskClass = vuln.risk === 'high' ? 'error' : vuln.risk === 'medium' ? 'warning' : 'info';
            await this.addScanLine(
                `Port ${vuln.port} (${vuln.service}) - ${vuln.risk.toUpperCase()} RISK - ${vuln.cve}`,
                riskClass
            );
        }
    }

    async checkPackages() {
        // Randomly select packages to check
        const packagesToCheck = this.archPackages
            .sort(() => Math.random() - 0.5)
            .slice(0, 5);
        
        for (const pkg of packagesToCheck) {
            await this.delay(300);
            const hasUpdate = Math.random() > 0.6;
            if (hasUpdate) {
                await this.addScanLine(`[UPDATE] ${pkg} â†’ newer version available`, 'warning');
            } else {
                await this.addScanLine(`[OK] ${pkg}`, 'success');
            }
        }
    }

    async addScanLine(text, type = 'info') {
        const line = document.createElement('div');
        line.className = `scanner-line ${type}`;
        
        const time = new Date().toLocaleTimeString('en-US', { hour12: false });
        line.innerHTML = `[<span class="time">${time}</span>] ${text}`;
        
        this.scannerOutput.appendChild(line);
        this.scannerOutput.scrollTop = this.scannerOutput.scrollHeight;
        
        // Add typing effect
        line.style.opacity = '0';
        line.style.transform = 'translateX(-10px)';
        
        requestAnimationFrame(() => {
            line.style.transition = 'all 0.3s ease';
            line.style.opacity = '1';
            line.style.transform = 'translateX(0)';
        });
    }

    updateASCIIStatus(status) {
        const asciiContainer = document.querySelector('.retro-pc-ascii');
        if (status === 'complete') {
            // Update the progress bar
            const progressBar = asciiContainer.textContent.replace('[â– â– â– â–¡â–¡]', '[â– â– â– â– â– ]');
            asciiContainer.textContent = progressBar.replace('SCANNING...', 'SCAN COMPLETE');
        }
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// ASCII art enhancements
class RetroPC {
    constructor() {
        this.leds = {
            pwr: true,
            hdd: false,
            net: false,
            cpu: false
        };
        this.ledElements = null;
    }

    init() {
        this.createLEDIndicators();
        this.animateLEDs();
    }

    createLEDIndicators() {
        const asciiContainer = document.querySelector('.retro-pc-ascii');
        
        // Add blinking cursor effect
        const cursor = document.createElement('span');
        cursor.className = 'blink-cursor';
        cursor.textContent = 'â–ˆ';
        
        // Add LED animations
        this.animateLEDs();
    }

    animateLEDs() {
        setInterval(() => {
            // Randomly blink LEDs
            this.leds.hdd = Math.random() > 0.7;
            this.leds.net = Math.random() > 0.5;
            this.leds.cpu = Math.random() > 0.6;
            
            // Update visual indicators if needed
        }, 500);
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    // Remove donut animation if it exists
    if (window.donutAnimation) {
        window.donutAnimation.stop();
        window.donutAnimation = null;
    }
    
    // Start vulnerability scanner
    const scanner = new VulnerabilityScanner();
    const retroPC = new RetroPC();
    
    scanner.init();
    retroPC.init();
    
    // Store globally for access
    window.vulnerabilityScanner = scanner;
    window.retroPC = retroPC;
}); 