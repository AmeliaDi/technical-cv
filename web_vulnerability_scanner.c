/*
 * Advanced Web Vulnerability Scanner
 * Author: AmeliaDi <enorastrokes@gmail.com>
 * License: GPL v2
 * 
 * A comprehensive web vulnerability scanner designed to identify common
 * security flaws in web applications including SQL injection, XSS, CSRF,
 * directory traversal, and various other vulnerabilities.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <curl/curl.h>
#include <json-c/json.h>
#include <pthread.h>
#include <time.h>
#include <regex.h>
#include <libxml/HTMLparser.h>
#include <libxml/tree.h>
#include <signal.h>
#include <sys/stat.h>

#include "web_vulnerability_scanner.h"

// Global variables
scan_config_t *global_config = NULL;
scan_statistics_t scan_stats = {0};
pthread_mutex_t stats_mutex = PTHREAD_MUTEX_INITIALIZER;
int stop_scanning = 0;

// Signal handler for graceful shutdown
void signal_handler(int sig) {
    if (sig == SIGINT || sig == SIGTERM) {
        printf("\n[INFO] Received signal %d, shutting down gracefully...\n", sig);
        stop_scanning = 1;
    }
}

// Main scanner function
int main(int argc, char *argv[]) {
    scan_config_t config = {0};
    scan_result_t *results = NULL;
    int result_count = 0;
    
    // Set up signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    printf("Advanced Web Vulnerability Scanner v1.0\n");
    printf("Author: AmeliaDi <enorastrokes@gmail.com>\n");
    printf("========================================\n\n");
    
    // Parse command line arguments
    if (parse_arguments(argc, argv, &config) != 0) {
        print_usage(argv[0]);
        return EXIT_FAILURE;
    }
    
    global_config = &config;
    
    // Initialize libcurl
    if (curl_global_init(CURL_GLOBAL_DEFAULT) != CURLE_OK) {
        fprintf(stderr, "[ERROR] Failed to initialize libcurl\n");
        return EXIT_FAILURE;
    }
    
    // Initialize XML parser
    xmlInitParser();
    LIBXML_TEST_VERSION;
    
    // Validate target URL
    if (validate_url(config.target_url) != 0) {
        fprintf(stderr, "[ERROR] Invalid target URL: %s\n", config.target_url);
        cleanup_and_exit(EXIT_FAILURE);
    }
    
    printf("[INFO] Starting vulnerability scan against: %s\n", config.target_url);
    printf("[INFO] Scan depth: %d\n", config.max_depth);
    printf("[INFO] Thread count: %d\n", config.thread_count);
    printf("[INFO] Output format: %s\n", 
           config.output_format == OUTPUT_JSON ? "JSON" : 
           config.output_format == OUTPUT_XML ? "XML" : "Text");
    
    if (config.output_file) {
        printf("[INFO] Output file: %s\n", config.output_file);
    }
    
    printf("\n");
    
    // Initialize scan statistics
    init_scan_statistics();
    
    // Start the main scanning process
    clock_t start_time = clock();
    
    if (start_vulnerability_scan(&config, &results, &result_count) != 0) {
        fprintf(stderr, "[ERROR] Vulnerability scan failed\n");
        cleanup_and_exit(EXIT_FAILURE);
    }
    
    clock_t end_time = clock();
    double scan_duration = ((double)(end_time - start_time)) / CLOCKS_PER_SEC;
    
    // Update final statistics
    pthread_mutex_lock(&stats_mutex);
    scan_stats.total_scan_time = scan_duration;
    pthread_mutex_unlock(&stats_mutex);
    
    // Generate and output results
    printf("\n[INFO] Scan completed in %.2f seconds\n", scan_duration);
    printf("[INFO] Found %d vulnerabilities\n", result_count);
    
    if (generate_report(&config, results, result_count) != 0) {
        fprintf(stderr, "[ERROR] Failed to generate report\n");
    }
    
    // Print scan statistics
    print_scan_statistics();
    
    // Cleanup
    free_scan_results(results, result_count);
    cleanup_and_exit(EXIT_SUCCESS);
    
    return EXIT_SUCCESS;
}

// Parse command line arguments
int parse_arguments(int argc, char *argv[], scan_config_t *config) {
    int opt;
    
    // Set default values
    config->max_depth = DEFAULT_MAX_DEPTH;
    config->thread_count = DEFAULT_THREAD_COUNT;
    config->timeout = DEFAULT_TIMEOUT;
    config->output_format = OUTPUT_TEXT;
    config->aggressive_mode = 0;
    config->include_info = 0;
    config->follow_redirects = 1;
    config->verify_ssl = 1;
    config->user_agent = DEFAULT_USER_AGENT;
    config->max_requests = DEFAULT_MAX_REQUESTS;
    config->request_delay = DEFAULT_REQUEST_DELAY;
    
    while ((opt = getopt(argc, argv, "u:d:t:T:o:f:hvaisk")) != -1) {
        switch (opt) {
            case 'u':
                config->target_url = optarg;
                break;
            case 'd':
                config->max_depth = atoi(optarg);
                if (config->max_depth <= 0 || config->max_depth > MAX_SCAN_DEPTH) {
                    fprintf(stderr, "[ERROR] Invalid depth: %s (1-%d)\n", 
                            optarg, MAX_SCAN_DEPTH);
                    return -1;
                }
                break;
            case 't':
                config->thread_count = atoi(optarg);
                if (config->thread_count <= 0 || config->thread_count > MAX_THREADS) {
                    fprintf(stderr, "[ERROR] Invalid thread count: %s (1-%d)\n", 
                            optarg, MAX_THREADS);
                    return -1;
                }
                break;
            case 'T':
                config->timeout = atoi(optarg);
                if (config->timeout <= 0 || config->timeout > MAX_TIMEOUT) {
                    fprintf(stderr, "[ERROR] Invalid timeout: %s (1-%d)\n", 
                            optarg, MAX_TIMEOUT);
                    return -1;
                }
                break;
            case 'o':
                config->output_file = optarg;
                break;
            case 'f':
                if (strcmp(optarg, "text") == 0) {
                    config->output_format = OUTPUT_TEXT;
                } else if (strcmp(optarg, "json") == 0) {
                    config->output_format = OUTPUT_JSON;
                } else if (strcmp(optarg, "xml") == 0) {
                    config->output_format = OUTPUT_XML;
                } else {
                    fprintf(stderr, "[ERROR] Invalid output format: %s\n", optarg);
                    return -1;
                }
                break;
            case 'a':
                config->aggressive_mode = 1;
                break;
            case 'v':
                config->verbose = 1;
                break;
            case 'i':
                config->include_info = 1;
                break;
            case 's':
                config->verify_ssl = 0;
                break;
            case 'k':
                config->follow_redirects = 0;
                break;
            case 'h':
                print_usage(argv[0]);
                exit(EXIT_SUCCESS);
            default:
                return -1;
        }
    }
    
    if (!config->target_url) {
        fprintf(stderr, "[ERROR] Target URL is required\n");
        return -1;
    }
    
    return 0;
}

// Print usage information
void print_usage(const char *program_name) {
    printf("Usage: %s -u <target_url> [options]\n\n", program_name);
    printf("Required:\n");
    printf("  -u <url>     Target URL to scan\n\n");
    printf("Options:\n");
    printf("  -d <depth>   Maximum crawl depth (default: %d, max: %d)\n", 
           DEFAULT_MAX_DEPTH, MAX_SCAN_DEPTH);
    printf("  -t <threads> Number of threads (default: %d, max: %d)\n", 
           DEFAULT_THREAD_COUNT, MAX_THREADS);
    printf("  -T <timeout> Request timeout in seconds (default: %d)\n", DEFAULT_TIMEOUT);
    printf("  -o <file>    Output file (default: stdout)\n");
    printf("  -f <format>  Output format: text, json, xml (default: text)\n");
    printf("  -a           Enable aggressive scanning mode\n");
    printf("  -v           Verbose output\n");
    printf("  -i           Include informational findings\n");
    printf("  -s           Skip SSL certificate verification\n");
    printf("  -k           Don't follow redirects\n");
    printf("  -h           Show this help message\n\n");
    printf("Examples:\n");
    printf("  %s -u http://example.com\n", program_name);
    printf("  %s -u https://example.com -d 3 -t 10 -f json -o results.json\n", program_name);
    printf("  %s -u http://example.com -a -v -i\n", program_name);
}

// Validate URL format
int validate_url(const char *url) {
    regex_t regex;
    int ret;
    
    // Basic URL validation regex
    const char *pattern = "^https?://[a-zA-Z0-9.-]+[a-zA-Z0-9/._-]*$";
    
    ret = regcomp(&regex, pattern, REG_EXTENDED);
    if (ret) {
        return -1;
    }
    
    ret = regexec(&regex, url, 0, NULL, 0);
    regfree(&regex);
    
    return ret == 0 ? 0 : -1;
}

// Initialize scan statistics
void init_scan_statistics(void) {
    pthread_mutex_lock(&stats_mutex);
    memset(&scan_stats, 0, sizeof(scan_statistics_t));
    scan_stats.scan_start_time = time(NULL);
    pthread_mutex_unlock(&stats_mutex);
}

// Update scan statistics
void update_scan_statistics(stat_type_t type, int count) {
    pthread_mutex_lock(&stats_mutex);
    
    switch (type) {
        case STAT_REQUESTS_SENT:
            scan_stats.total_requests += count;
            break;
        case STAT_RESPONSES_RECEIVED:
            scan_stats.total_responses += count;
            break;
        case STAT_VULNERABILITIES_FOUND:
            scan_stats.vulnerabilities_found += count;
            break;
        case STAT_PAGES_CRAWLED:
            scan_stats.pages_crawled += count;
            break;
        case STAT_FORMS_FOUND:
            scan_stats.forms_found += count;
            break;
        case STAT_ERRORS_ENCOUNTERED:
            scan_stats.errors_encountered += count;
            break;
    }
    
    pthread_mutex_unlock(&stats_mutex);
}

// Print scan statistics
void print_scan_statistics(void) {
    pthread_mutex_lock(&stats_mutex);
    
    printf("\n========== Scan Statistics ==========\n");
    printf("Scan duration:        %.2f seconds\n", scan_stats.total_scan_time);
    printf("Total requests:       %d\n", scan_stats.total_requests);
    printf("Total responses:      %d\n", scan_stats.total_responses);
    printf("Pages crawled:        %d\n", scan_stats.pages_crawled);
    printf("Forms found:          %d\n", scan_stats.forms_found);
    printf("Vulnerabilities:      %d\n", scan_stats.vulnerabilities_found);
    printf("Errors encountered:   %d\n", scan_stats.errors_encountered);
    
    if (scan_stats.total_requests > 0) {
        printf("Success rate:         %.1f%%\n", 
               (float)scan_stats.total_responses / scan_stats.total_requests * 100);
    }
    
    printf("=====================================\n");
    
    pthread_mutex_unlock(&stats_mutex);
}

// Start vulnerability scanning
int start_vulnerability_scan(scan_config_t *config, scan_result_t **results, int *result_count) {
    crawler_context_t crawler_ctx = {0};
    vulnerability_context_t vuln_ctx = {0};
    
    // Initialize crawler context
    if (init_crawler_context(&crawler_ctx, config) != 0) {
        fprintf(stderr, "[ERROR] Failed to initialize crawler context\n");
        return -1;
    }
    
    // Initialize vulnerability testing context
    if (init_vulnerability_context(&vuln_ctx, config) != 0) {
        fprintf(stderr, "[ERROR] Failed to initialize vulnerability context\n");
        free_crawler_context(&crawler_ctx);
        return -1;
    }
    
    printf("[INFO] Starting web crawling phase...\n");
    
    // Phase 1: Web crawling and discovery
    if (crawl_website(&crawler_ctx) != 0) {
        fprintf(stderr, "[ERROR] Web crawling failed\n");
        free_vulnerability_context(&vuln_ctx);
        free_crawler_context(&crawler_ctx);
        return -1;
    }
    
    printf("[INFO] Crawling completed. Found %d unique URLs\n", crawler_ctx.url_count);
    printf("[INFO] Starting vulnerability testing phase...\n");
    
    // Phase 2: Vulnerability testing
    if (test_vulnerabilities(&vuln_ctx, &crawler_ctx, results, result_count) != 0) {
        fprintf(stderr, "[ERROR] Vulnerability testing failed\n");
        free_vulnerability_context(&vuln_ctx);
        free_crawler_context(&crawler_ctx);
        return -1;
    }
    
    printf("[INFO] Vulnerability testing completed\n");
    
    // Cleanup contexts
    free_vulnerability_context(&vuln_ctx);
    free_crawler_context(&crawler_ctx);
    
    return 0;
}

// Generate report based on configuration
int generate_report(scan_config_t *config, scan_result_t *results, int result_count) {
    FILE *output_fp = stdout;
    
    if (config->output_file) {
        output_fp = fopen(config->output_file, "w");
        if (!output_fp) {
            fprintf(stderr, "[ERROR] Cannot open output file: %s\n", config->output_file);
            return -1;
        }
    }
    
    switch (config->output_format) {
        case OUTPUT_TEXT:
            generate_text_report(output_fp, config, results, result_count);
            break;
        case OUTPUT_JSON:
            generate_json_report(output_fp, config, results, result_count);
            break;
        case OUTPUT_XML:
            generate_xml_report(output_fp, config, results, result_count);
            break;
        default:
            fprintf(stderr, "[ERROR] Unknown output format\n");
            if (output_fp != stdout) fclose(output_fp);
            return -1;
    }
    
    if (output_fp != stdout) {
        fclose(output_fp);
        printf("[INFO] Report saved to: %s\n", config->output_file);
    }
    
    return 0;
}

// Generate text report
void generate_text_report(FILE *fp, scan_config_t *config, scan_result_t *results, int count) {
    fprintf(fp, "Web Vulnerability Scan Report\n");
    fprintf(fp, "=============================\n\n");
    fprintf(fp, "Target URL: %s\n", config->target_url);
    fprintf(fp, "Scan Time: %s", ctime(&scan_stats.scan_start_time));
    fprintf(fp, "Total Vulnerabilities Found: %d\n\n", count);
    
    // Group results by severity
    int critical = 0, high = 0, medium = 0, low = 0, info = 0;
    
    for (int i = 0; i < count; i++) {
        switch (results[i].severity) {
            case SEVERITY_CRITICAL: critical++; break;
            case SEVERITY_HIGH: high++; break;
            case SEVERITY_MEDIUM: medium++; break;
            case SEVERITY_LOW: low++; break;
            case SEVERITY_INFO: info++; break;
        }
    }
    
    fprintf(fp, "Severity Summary:\n");
    fprintf(fp, "- Critical: %d\n", critical);
    fprintf(fp, "- High:     %d\n", high);
    fprintf(fp, "- Medium:   %d\n", medium);
    fprintf(fp, "- Low:      %d\n", low);
    if (config->include_info) {
        fprintf(fp, "- Info:     %d\n", info);
    }
    fprintf(fp, "\n");
    
    // Detailed findings
    fprintf(fp, "Detailed Findings:\n");
    fprintf(fp, "==================\n\n");
    
    for (int i = 0; i < count; i++) {
        if (!config->include_info && results[i].severity == SEVERITY_INFO) {
            continue;
        }
        
        fprintf(fp, "[%d] %s\n", i + 1, results[i].title);
        fprintf(fp, "Severity: %s\n", severity_to_string(results[i].severity));
        fprintf(fp, "Type: %s\n", vulnerability_type_to_string(results[i].type));
        fprintf(fp, "URL: %s\n", results[i].url);
        
        if (results[i].parameter[0]) {
            fprintf(fp, "Parameter: %s\n", results[i].parameter);
        }
        
        fprintf(fp, "Description: %s\n", results[i].description);
        
        if (results[i].evidence[0]) {
            fprintf(fp, "Evidence: %s\n", results[i].evidence);
        }
        
        if (results[i].recommendation[0]) {
            fprintf(fp, "Recommendation: %s\n", results[i].recommendation);
        }
        
        fprintf(fp, "\n");
    }
}

// Generate JSON report
void generate_json_report(FILE *fp, scan_config_t *config, scan_result_t *results, int count) {
    json_object *root = json_object_new_object();
    json_object *scan_info = json_object_new_object();
    json_object *vulnerabilities = json_object_new_array();
    
    // Scan information
    json_object_object_add(scan_info, "target_url", 
                          json_object_new_string(config->target_url));
    json_object_object_add(scan_info, "scan_time", 
                          json_object_new_int64(scan_stats.scan_start_time));
    json_object_object_add(scan_info, "duration", 
                          json_object_new_double(scan_stats.total_scan_time));
    json_object_object_add(scan_info, "total_vulnerabilities", 
                          json_object_new_int(count));
    
    json_object_object_add(root, "scan_info", scan_info);
    
    // Vulnerabilities
    for (int i = 0; i < count; i++) {
        if (!config->include_info && results[i].severity == SEVERITY_INFO) {
            continue;
        }
        
        json_object *vuln = json_object_new_object();
        
        json_object_object_add(vuln, "id", json_object_new_int(i + 1));
        json_object_object_add(vuln, "title", json_object_new_string(results[i].title));
        json_object_object_add(vuln, "severity", 
                              json_object_new_string(severity_to_string(results[i].severity)));
        json_object_object_add(vuln, "type", 
                              json_object_new_string(vulnerability_type_to_string(results[i].type)));
        json_object_object_add(vuln, "url", json_object_new_string(results[i].url));
        json_object_object_add(vuln, "parameter", json_object_new_string(results[i].parameter));
        json_object_object_add(vuln, "description", json_object_new_string(results[i].description));
        json_object_object_add(vuln, "evidence", json_object_new_string(results[i].evidence));
        json_object_object_add(vuln, "recommendation", json_object_new_string(results[i].recommendation));
        
        json_object_array_add(vulnerabilities, vuln);
    }
    
    json_object_object_add(root, "vulnerabilities", vulnerabilities);
    
    fprintf(fp, "%s\n", json_object_to_json_string_ext(root, JSON_C_TO_STRING_PRETTY));
    
    json_object_put(root);
}

// Generate XML report
void generate_xml_report(FILE *fp, scan_config_t *config, scan_result_t *results, int count) {
    fprintf(fp, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fprintf(fp, "<vulnerability_scan_report>\n");
    fprintf(fp, "  <scan_info>\n");
    fprintf(fp, "    <target_url>%s</target_url>\n", config->target_url);
    fprintf(fp, "    <scan_time>%ld</scan_time>\n", scan_stats.scan_start_time);
    fprintf(fp, "    <duration>%.2f</duration>\n", scan_stats.total_scan_time);
    fprintf(fp, "    <total_vulnerabilities>%d</total_vulnerabilities>\n", count);
    fprintf(fp, "  </scan_info>\n");
    fprintf(fp, "  <vulnerabilities>\n");
    
    for (int i = 0; i < count; i++) {
        if (!config->include_info && results[i].severity == SEVERITY_INFO) {
            continue;
        }
        
        fprintf(fp, "    <vulnerability id=\"%d\">\n", i + 1);
        fprintf(fp, "      <title><![CDATA[%s]]></title>\n", results[i].title);
        fprintf(fp, "      <severity>%s</severity>\n", severity_to_string(results[i].severity));
        fprintf(fp, "      <type>%s</type>\n", vulnerability_type_to_string(results[i].type));
        fprintf(fp, "      <url><![CDATA[%s]]></url>\n", results[i].url);
        fprintf(fp, "      <parameter><![CDATA[%s]]></parameter>\n", results[i].parameter);
        fprintf(fp, "      <description><![CDATA[%s]]></description>\n", results[i].description);
        fprintf(fp, "      <evidence><![CDATA[%s]]></evidence>\n", results[i].evidence);
        fprintf(fp, "      <recommendation><![CDATA[%s]]></recommendation>\n", results[i].recommendation);
        fprintf(fp, "    </vulnerability>\n");
    }
    
    fprintf(fp, "  </vulnerabilities>\n");
    fprintf(fp, "</vulnerability_scan_report>\n");
}

// Convert severity enum to string
const char* severity_to_string(severity_t severity) {
    switch (severity) {
        case SEVERITY_CRITICAL: return "Critical";
        case SEVERITY_HIGH: return "High";
        case SEVERITY_MEDIUM: return "Medium";
        case SEVERITY_LOW: return "Low";
        case SEVERITY_INFO: return "Informational";
        default: return "Unknown";
    }
}

// Convert vulnerability type enum to string
const char* vulnerability_type_to_string(vulnerability_type_t type) {
    switch (type) {
        case VULN_SQL_INJECTION: return "SQL Injection";
        case VULN_XSS_REFLECTED: return "Reflected XSS";
        case VULN_XSS_STORED: return "Stored XSS";
        case VULN_XSS_DOM: return "DOM XSS";
        case VULN_CSRF: return "Cross-Site Request Forgery";
        case VULN_DIRECTORY_TRAVERSAL: return "Directory Traversal";
        case VULN_FILE_INCLUSION: return "File Inclusion";
        case VULN_COMMAND_INJECTION: return "Command Injection";
        case VULN_LDAP_INJECTION: return "LDAP Injection";
        case VULN_XPATH_INJECTION: return "XPath Injection";
        case VULN_XXE: return "XML External Entity";
        case VULN_SSRF: return "Server-Side Request Forgery";
        case VULN_OPEN_REDIRECT: return "Open Redirect";
        case VULN_WEAK_AUTHENTICATION: return "Weak Authentication";
        case VULN_SESSION_FIXATION: return "Session Fixation";
        case VULN_INSECURE_DIRECT_OBJECT_REF: return "Insecure Direct Object Reference";
        case VULN_MISSING_SECURITY_HEADERS: return "Missing Security Headers";
        case VULN_INFORMATION_DISCLOSURE: return "Information Disclosure";
        case VULN_CLICKJACKING: return "Clickjacking";
        case VULN_SECURITY_MISCONFIGURATION: return "Security Misconfiguration";
        default: return "Unknown";
    }
}

// Free scan results
void free_scan_results(scan_result_t *results, int count) {
    if (results) {
        free(results);
    }
}

// Cleanup and exit
void cleanup_and_exit(int exit_code) {
    // Cleanup libcurl
    curl_global_cleanup();
    
    // Cleanup libxml2
    xmlCleanupParser();
    
    exit(exit_code);
} 